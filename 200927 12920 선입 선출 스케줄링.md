# 200927 12920 선입 선출 스케줄링

###### 문제 설명

처리해야 할 동일한 작업이 n 개가 있고, 이를 처리하기 위한 CPU가 있습니다.

이 CPU는 다음과 같은 특징이 있습니다.

- CPU에는 여러 개의 코어가 있고, 코어별로 한 작업을 처리하는 시간이 다릅니다.
- 한 코어에서 작업이 끝나면 작업이 없는 코어가 바로 다음 작업을 수행합니다.
- 2개 이상의 코어가 남을 경우 앞의 코어부터 작업을 처리 합니다.

처리해야 될 작업의 개수 n과, 각 코어의 처리시간이 담긴 배열 cores 가 매개변수로 주어질 때, 마지막 작업을 처리하는 코어의 번호를 return 하는 solution 함수를 완성해주세요.

##### 제한 사항

- 코어의 수는 10,000 이하 2이상 입니다.
- 코어당 작업을 처리하는 시간은 10,000이하 입니다.
- 처리해야 하는 일의 개수는 50,000개를 넘기지 않습니다.

------

##### 입출력 예

| n    | cores   | result |
| ---- | ------- | ------ |
| 6    | [1,2,3] | 2      |

##### 입출력 예 설명

입출력 예 #1
처음 3개의 작업은 각각 1,2,3번에 들어가고, 1시간 뒤 1번 코어에 4번째 작업,다시 1시간 뒤 1,2번 코어에 5,6번째 작업이 들어가므로 2를 반환해주면 됩니다.

---

## 200927 Code

* 파라메트릭 서치 알고리즘 활용

1. 시간을 기준으로 min_time과 max_time을 두어 중간값을 구한다.
   1. 탐색을 진행하며 시간 기준 최대 코어 작업 갯수를 구하고
   2. 최대 코어 작업 갯수가 처리해야할 코어 작업 수보다 작을 경우, min_time을 늘려주고
   3. 그 외의 경우에는 max_time을 늘려준다.
2. 완료조건은 min_time이 max_time-1일 경우, mid 값, 즉 최적 시간이 더 이상 변하지 않기 때문에, 해당 시간일때 처리해야할 작업과 가장 근사한 처리된 작업 수가 나온다.
3. 최적 시간을 구한 뒤, 그 시간 기준으로 cores를 탐색하며 현재 작업이 진행 중인지 아닌지를 판단 후, 아닌 경우만 visited에 코어 번호(index+1)를 따로 저장
4. 처리해야할 작업 수가 최적 시간에서의 처리 작업수보다 항상 같거나 크므로, 추가적으로 몇개의 작업을 더 처리해야하는지 구한다.
5. 추가 작업 수-1은 visited 배열의 index와 동일

```python
def solution(n, cores):
    n_cores = len(cores)
    min_time = 0
    max_time = min(cores) * n
    if n <= n_cores: return n
    while min_time < max_time-1:
        mid = (min_time + max_time) // 2
        total = 0
        for core in cores:
            total += (mid // core) + 1
        if total >= n:
            max_time = mid
        else:
            min_time = mid
    max_core = 0
    visited = []
    for i in range(n_cores):
        max_core += (min_time + 1) // cores[i] + 1
        if not (min_time + 1) % cores[i]:
            visited.append(i+1)
    answer = visited[n-max_core-1]
    return answer
```

